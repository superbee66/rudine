using System;
using System.Collections.Generic;
using System.Linq;
using Rudine.Web;

namespace Rudine.Interpreters.Embeded
{
    public static class ExternalInterpreterFactory
    {
        private const string CSharpFormat = @"
    
    using System;
    using System.Collections.Generic;
    using Rudine.Interpreters.Embeded;
    using Rudine.Web;
    
    public class External{0} : {1}.{0}
    {{
        private readonly string MyOnlyDocVersion =
            ""1.0.0.0"";

        private string MyOnlyDocName {{ get {{
            return GetType().Name.Replace(""Interpreter"", string.Empty); }} }}

        private string WrapperBytesFileName {{ get {{
            return AutoFileName(MyOnlyDocName, ContentInfo.ContentFileExtension); }} }}

        public override bool Processable(string docTypeName, string docRev) {{
            return 
            docTypeName == MyOnlyDocName
            &&
            docRev == MyOnlyDocVersion; }}

        public override string ReadDocRev(byte[] docData) {{
            return MyOnlyDocVersion; }}

        public override string ReadDocTypeName(byte[] docData) {{
            return MyOnlyDocName; }}

        public override byte[] WritePI(byte[] docData, DocProcessingInstructions pi) {{
            return ExternalInterpreterFactory.WritePiInternal(docData, pi, WrapperBytesFileName); }}
    }}
";

        public static T CreateInstance<T>(T baseOn) where T : DocBaseInterpreter
        {
            Type _Type = baseOn.GetType();

            T _Instance = (T)Activator.CreateInstance(
                Runtime.CompileCSharpCode(() =>
                        string.Format(
                        CSharpFormat,
                        _Type.Name,
                        _Type.Namespace))
                    .GetTypes()
                    .First(t => t.BaseType == _Type));

            return _Instance;
        }

        public static byte[] AsDocRev(byte[] docData, DocProcessingInstructions pi, string wrapperBytesFileName)
        {
            DocRev _ExternalPdfDoc = new DocRev
            {
                DocChecksum = default(int),
                DocFiles = new List<DocRevEntry>
                {
                    new DocRevEntry
                    {
                        Bytes = docData,
                        ModDate = DateTime.Now,
                        Name = wrapperBytesFileName
                    }
                },
                DocKeys = pi.DocKeys,
                DocSchema = null,
                DocSrc = pi.DocSrc,
                DocStatus = pi.DocStatus,
                DocTitle = pi.DocTitle,
                DocTypeName = DocRev.MyOnlyDocName,
                DocURN = new DocURN
                {
                    DocTypeName = wrapperBytesFileName,
                    solutionVersion = DocRev.MyOnlyDocVersion
                },
                name = null,
                solutionVersion = DocRev.MyOnlyDocVersion
            };

            _ExternalPdfDoc.DocChecksum = _ExternalPdfDoc.DocFilesMD5.GetHashCode();

            return DocRevInterpreter.Instance.WriteByte(_ExternalPdfDoc);
        }
    }
}